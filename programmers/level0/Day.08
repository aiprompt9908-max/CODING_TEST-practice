# Programmers Beginner - Day 08 (Python)

---

# 1️⃣ 배열 자르기

## 문제 설명
정수 배열 `numbers`와 정수 `num1`, `num2`가 주어질 때  
`num1`부터 `num2`까지의 배열을 return하는 함수 작성

---

## 풀이 아이디어

Python의 **슬라이싱(Slicing)**을 사용한다.

슬라이싱 기본 구조

```
list[start:stop:step]
```

- start → 시작 index (포함)
- stop → 끝 index (포함 X)
- step → 간격

그래서 `num2`까지 포함하려면

```
num2 + 1
```

을 사용해야 한다.

---

## 코드

```python
def solution(numbers, num1, num2):
    return numbers[num1:num2+1]
```

---

## slicing 정리

```
a[1:4]   → 1~3
a[:3]    → 처음~2
a[2:]    → 2부터 끝
a[:]     → 전체 복사
a[::2]   → 2칸 간격
a[::-1]  → 뒤집기
```

---

# 2️⃣ 외계행성의 나이

## 문제 설명

나이를 문자열로 변환하는 규칙

```
0 → a
1 → b
2 → c
...
9 → j
```

예

```
age = 23
→ "cd"
```

---

## 풀이 아이디어

1️⃣ 숫자를 문자열로 변환

```
str(age)
```

2️⃣ 문자열을 순회

3️⃣ 숫자를 index로 사용

---

## 코드

```python
def solution(age):
    table = "abcdefghij"
    return "".join(table[int(i)] for i in str(age))
```

---

## 핵심 포인트

```
str(age)
```

숫자를 문자열로 바꿔서

```
1
2
3
```

처럼 하나씩 접근할 수 있다.

---

# 3️⃣ 진료 순서 정하기

## 문제 설명

응급도가 높은 순서대로 순위를 매긴다.

---

## 풀이 아이디어

1️⃣ 리스트를 내림차순 정렬

```
sorted(emergency, reverse=True)
```

2️⃣ 정렬된 리스트에서 index 찾기

```
index()
```

---

## 코드

```python
def solution(emergency):
    sorted_e = sorted(emergency, reverse=True)
    return [sorted_e.index(e) + 1 for e in emergency]
```

---

## 개선 풀이 (추천)

index()는 매번 탐색하기 때문에 느릴 수 있다.  
그래서 dictionary로 rank를 저장하면 더 효율적이다.

```python
def solution(emergency):
    sorted_e = sorted(emergency, reverse=True)
    rank = {v: i + 1 for i, v in enumerate(sorted_e)}
    return [rank[e] for e in emergency]
```

---

# 4️⃣ 순서쌍의 개수

## 문제 설명

두 숫자의 곱이 `n`이 되는 자연수 순서쌍 `(a, b)`의 개수

---

## 핵심 아이디어

```
a × b = n
```

이면

```
a
```

는 반드시

```
n의 약수
```

이다.

즉 이 문제는

```
n의 약수 개수
```

를 구하는 문제와 같다.

---

## 코드

```python
def solution(n):
    count = 0
    for i in range(1, n+1):
        if n % i == 0:
            count += 1
    return count
```

---

## 개선 풀이 (√n)

약수는

```
sqrt(n)
```

까지만 검사하면 된다.

```python
import math

def solution(n):
    count = 0
    for i in range(1, int(math.sqrt(n))+1):
        if n % i == 0:
            count += 2
    if int(math.sqrt(n))**2 == n:
        count -= 1
    return count
```

---

# ✏️ Reflection

이 문제가 **n의 약수를 세는 문제와 같다는 새로운 시각이 흥미로웠다.**

この問題が **nの約数を数える問題と同じだという考え方** がとても面白かった。

그 방법을 알고 나니 내가 알고 있는 방법으로 해결할 수 있었다。

その方法を知ってから、自分が知っている方法で解決することができた。
